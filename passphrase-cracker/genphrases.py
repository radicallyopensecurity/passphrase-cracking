#!/usr/bin/env pypy

import sys
from lib import *

if '-h' in sys.argv or '--help' in sys.argv or len(sys.argv) == 1:
    print(
'''Usage:

  genphrases.py [-v] [-n <n>] [-m <minfreq>] <ngrams-file> <minlen> <maxlen>

Generated phrases will be outputted to stdout. They are space-separated and
meant to be used with the included hashcat rules.

Arguments:
  <ngrams-file>
    A file with ngrams, generated by the companion tool, in sorted order. This
    is loaded into memory (in memory, it is about 17.5x larger than on disk due
    to both indexing and Python's overhead, unless you use -m).

  <minlen>
    Minimum number of words in each outputted phrase.

  <maxlen>
    Maximum number of words in each outputted phrase.

  -m <minfreq>
    Set a minimum frequency for the n-gram file, i.e. skip any lines with a
    frequency of smaller than or equal to minfreq. Useful for limited memory.
    A value of 2 often greatly reduces the memory footprint.

  -v
    Verbose mode. Messages are written to stderr.

  -n <n>
    Set the number of words in each n-gram to <n>, allowing the program to
    treat lines with an incorrect number of words in the ngrams file as warning
    instead of an error.

Exit statuses:
  0: OK
  1: Error in arguments
  2: Error in ngrams file
''')
    exit(1)

minfreq = -1
if '-m' in sys.argv:
    i = sys.argv.index('-m')
    minfreq = int(sys.argv[i + 1])
    del sys.argv[i]
    del sys.argv[i]  # not i+1 because it shifted

verbose = False
if '-v' in sys.argv:
    verbose = True
    del sys.argv[sys.argv.index('-v')]

n = None
''' The n value of the n-grams, e.g. 3 for trigrams. '''

warnForIncorrectN = False
if '-n' in sys.argv:
    i = sys.argv.index('-n')
    n = int(sys.argv[i + 1])
    del sys.argv[i]
    del sys.argv[i]  # not i+1 because it shifted
    warnForIncorrectN = True

index = {}
''' Index of n-1 words, pointing to each previous n-gram starting with those words.
For example:
    index["there was"] = [1, 9] if
        n == 3 and ngrams[1] == "there was a" and ngrams[9] == "there was one"
Note that the array is in ascending order (highest frequency first).
'''

ngrams = []
''' Array of all ngrams in ascending order of frequency. '''

if len(sys.argv) != 4:
    err('Too few arguments.')
    exit(1)

minlen = int(sys.argv[2])
maxlen = int(sys.argv[3])

if minlen > maxlen:
    err('Error: the minimum length must be >= the maximum length.\n')
    exit(1)

if verbose: err('Loading and indexing ngrams...\n')

lastfrequency = -1
skippedBecauseMinfreq = 0
for i, line in enumerate(open(sys.argv[1])):
    if len(line.strip()) == 0 or line[0] == '#':
        continue

    try:
        frequency, gram = line.strip().lower().split(' ', 1)
        frequency = int(frequency)
    except:
        err('Warning: ngram line {} invalid: "{}"\n'.format(i, line.strip()))
        continue

    if frequency <= minfreq:
        skippedBecauseMinfreq += 1
        continue

    splitgram = gram.split(' ')

    if n is None:
        n = len(splitgram)
    elif len(splitgram) != n:
        msg = 'n!={} on line {} ("{}")\n'.format(n, i, line.strip())
        if warnForIncorrectN:
            err('Warning: ' + msg)
            continue

        err('Error: ' + msg)
        exit(2)

    if lastfrequency > frequency:
        err('Error: ngram file not in order of ascending frequency.\n')
        err('Please use `sort` on the ngrams file.\n')
        exit(2)

    ourindex = ' '.join(splitgram[:-1])
    if ourindex not in index:
        index[ourindex] = []
    index[ourindex].append(len(ngrams))

    nextindex = ' '.join(splitgram[1:])
    ngrams.append((gram, nextindex, splitgram[-1]))

    lastfrequency = frequency

if verbose: err('Skipped {} because they are <= -m\n'.format(skippedBecauseMinfreq))

for indexgram in index:
    index[indexgram] = reversed(index[indexgram])

def doShortPhrases():
    if minlen < n:
        # To optimize later, we can already output the very short ones.
        # Then we don't have to check for this later.
        for i in range(len(ngrams) - 1, -1, -1):
            for j in range(max(minlen, 1), min(n, maxlen + 1)):
                print(' '.join(ngrams[i][0].split(' ')[0:j]))

        if maxlen < n:
            # Oh that's all we wanted? Then we're done.
            exit(0)

    if maxlen == n:
        # We only want things up to n? Output and exit.
        for i in range(len(ngrams) - 1, -1, -1):
            print(ngrams[i][0])

        exit(0)

def permute(state, indexgram, length):
    if length == maxlen - 1:
        if indexgram in index:
            for i in index[indexgram]:
                print(state + ' ' + ngrams[i][2])

    else:
        if length >= minlen:
            print(state)

        if indexgram in index:
            for i in index[indexgram]:
                permute(state + ' ' + ngrams[i][2], ngrams[i][1], length + 1)

if verbose: err('Starting output of short phrases, if any...\n')
doShortPhrases()

if verbose: err('Starting general output...\n')
for i in range(len(ngrams) - 1, -1, -1):
    permute(ngrams[i][0], ngrams[i][1], n)

